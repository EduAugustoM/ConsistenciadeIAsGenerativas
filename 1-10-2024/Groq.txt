Aqui está o código em Python que resolve o problema de encontrar os números primos em um intervalo fornecido:
```python
def is_prime(n):
    """Verifica se um número é primo"""
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def find_primes(start, end):
    """Encontra os números primos em um intervalo"""
    primes = []
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    return primes

# Exemplo de uso
start = 10
end = 50
primes = find_primes(start, end)
print(primes)  # [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
```
Agora, vamos descrever como o código funciona:

**Função `is_prime(n)`**

Essa função verifica se um número `n` é primo. Ela faz isso verificando se `n` é divisível por qualquer número entre 2 e a raiz quadrada de `n` (incluso). Se `n` for divisível por algum desses números, então não é primo. Caso contrário, é primo.

A lógica por trás disso é que um número primo só pode ser dividido por 1 e por si mesmo. Portanto, se um número for divisível por outro número maior que 1, então não é primo.

**Função `find_primes(start, end)`**

Essa função encontra os números primos em um intervalo especificado por `start` e `end`. Ela itera sobre todos os números no intervalo e, para cada número, verifica se é primo usando a função `is_prime(n)`. Se for primo, adiciona-o à lista `primes`.

**Algoritmo**

O algoritmo utilizado é o seguinte:

1. Iterar sobre todos os números no intervalo `[start, end]`.
2. Para cada número, verificar se é primo usando a função `is_prime(n)`.
3. Se for primo, adicioná-lo à lista `primes`.
4. Retornar a lista `primes`.

**Complexidade**

A complexidade do algoritmo é O(n), pois precisamos verificar cada número no intervalo. No entanto, a função `is_prime(n)` tem uma complexidade média de O(√n), pois precisamos verificar se `n` é divisível por números até a raiz quadrada de `n`. Portanto, a complexidade total do algoritmo é O(n√n).

**Melhorias**

Existem algumas melhorias que podem ser feitas nesse algoritmo:

* Em vez de verificar se `n` é divisível por todos os números até a raiz quadrada de `n`, podemos apenas verificar se é divisível por números pares e por 3, pois esses são os únicos divisores possíveis de `n` que não são 1 ou `n` mesmo.
* Podemos também utilizar uma técnica chamada "sieve of Eratosthenes" para encontrar os números primos em um intervalo. Isso pode ser mais eficiente para grandes intervalos.

No entanto, para intervalos pequenos como o exemplo fornecido, o algoritmo atual é suficiente.